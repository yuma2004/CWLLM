# AGENT.md

# Output language policy

- Think in English internally.
- Output (all user-visible text) must be in Japanese.
- Do not include the English reasoning or chain-of-thought in the output.
- If you must use technical terms, keep them as-is but explain briefly in Japanese.
- For code comments: Japanese unless the existing file is English-only (then follow existing style).


## 0. このリポジトリでの目的
- 変更要求に対して「最小変更で確実に動く」実装・修正・リファクタを行う
- 既存仕様・既存挙動の破壊を避ける（互換性重視）
- 可能ならテストで担保（難しければ手動検証手順を残す）

---

## 1. 文章スタイルのルール（最重要）
### 1.1 Think（内部思考）
- **Thinkは英語で行う**（推論・整理・計画は英語で）

### 1.2 Answer（ユーザーに返す文章）
- **回答は日本語**で、**固すぎない**・**わかりやすい**・**流れるような自然な文章**にする  
- 余計な前置きは省く。要点→理由→次アクションの順で短くまとめる  
- 断定が難しい部分は「〜の可能性が高い」「〜が候補」と自然に濁す  
- **文末に「ますでしょうか」を使わない**

---

## 2. 最優先ルール（必ず守る）
1. **コンパイル / ビルド / Lint / テストが通る状態を維持**
2. **ユーザーが明示した要件・制約を最優先**（不明点は既存コードとREADMEを優先して推定）
3. **既存の設計・命名・ディレクトリ構造に合わせる**（勝手に流儀を持ち込まない）
4. **不要コード削除は安全確認してから**（参照探索→削除→テスト→差分説明）
5. **秘密情報を追加しない**（APIキー、トークン、個人情報、社内URL等をコミットしない）
6. **依存追加は最小限**（必要性・代替・影響を説明できる場合のみ）

---

## 3. 作業フロー（基本）
### 3.1 事前調査（着手前）
- `README` / `docs/` / 依存管理ファイルを確認
- 実行手順（dev/build/test）を把握
- 対象の入口（ルーティング、API、UI、CLI）を特定
- 影響範囲の探索（grep / ripgrep で参照箇所検索）

### 3.2 実装の進め方
- 変更は小さく分割して進める
- 既存の関数・型・境界を優先して拡張（全面改修は最後）
- 例外処理・入力検証・ログは既存方式に合わせる
- 追加した設定値は `.env.example` や `config` に集約（既存があればそこに追従）

### 3.3 完了条件
- 再現できる **実行手順 / テスト手順** が提示されている
- 主要ユースケースが動く（最低限）
- 差分の要点（何をどう変えたか、影響は何か）が説明されている

---

## 4. 出力フォーマット（PR/回答の書き方）
回答は次の順で出す（短く、自然な日本語で）。

1. **やったこと**（1〜3行）
2. **変更点**（箇条書き）
3. **影響範囲**（触った領域、互換性、移行が必要か）
4. **確認**（実行したコマンド or 手動手順）
5. **メモ**（懸念点、残タスク）

---

## 5. コーディング規約（共通）
- 命名は既存に合わせる（snake/camel/kebab）
- 関数は短く、責務を分ける（ネスト浅め、早期return）
- I/O境界（外部API、DB、FS）は抽象化しやすい形に寄せる
- ログ：PIIを出さない。エラーは原因が追える情報を残す
- 例外：握りつぶさない。呼び出し側で扱える形に整える

---

## 6. テスト方針
- 既存テストがあるなら同じフレームワークで追加
- ない場合：
  - 重要ロジックはユニットテストを追加（可能なら）
  - 難しければ **手動検証手順** を `docs/verification.md` などに追記
- 回帰リスクが高い箇所は優先的にテストで保護

---

## 7. リファクタリング方針（この順）
1. 未使用コード/死活コードの特定（参照検索、ルーティング/exports確認）
2. 重複の整理（共通化は小さく、差異を壊さない）
3. 依存の整理（不要依存の削除はビルド/テスト通過が条件）
4. 責務分割（巨大ファイルの分割、層分け）
5. 型/境界の明確化（入力、出力、例外、戻り値）

---

## 8. バグ修正の基本手順
- 再現条件（入力・環境・手順）を文章化
- 原因候補を絞るための観測点を追加（必要最小限）
- 修正は局所的に
- 再発防止としてテスト or 検証手順を追加

---

## 9. セキュリティ / コンプライアンス
- 認証・認可の変更は影響が大きいので慎重に（既存仕様に追従）
- 個人情報・機微情報をログ/レスポンス/例外に含めない
- SQL/テンプレート/シェル等のインジェクションに注意
- 外部APIはタイムアウト、リトライ方針、レート制限を考慮

---

## 10. 曖昧な依頼の扱い
止まらず、次の優先順で推定して進める。
1. 既存コードの挙動
2. README / docs の記載
3. 既存の命名・設計パターン
4. 一般的なベストプラクティス

ただし、仕様が分岐して手戻りが大きい場合は、実装前に「前提」と「選択肢」を短く提示する。

---

## 12. コミット粒度（推奨）
- 1コミット = 1目的（バグ修正、機能追加、リファクタ）
- 余計な整形変更を混ぜない（差分レビューを楽にする）
