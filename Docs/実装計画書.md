# 実装計画書（チケット駆動）

本書は `Docs/要件定義書.md` と `Docs/基本設計書.md`（MVP要約ツール）を前提に、チケット単位で「実装→実行→挙動確認→次へ」を回せるようにするための計画書です。

---

## 0. 前提・ゴール

### 0.1 MVPのゴール（基本設計書より）
- 顧客名を選ぶと、その顧客との Chatwork の直近のやり取りが「要約（日本語）」として表示される
- 必要なら直近メッセージ（生ログ）も見られる
- 顧客と Chatwork ルームの紐づけを管理できる
- 社内ユーザーのみが使える最低限の認証がある

### 0.2 MVPでやらないこと（基本設計書より）
- タスク抽出・タスク管理（一覧、期日、担当、ステータス、編集）
- 通知・リマインド、日次/週次レポート
- 複数チャットツール対応、厳密な権限管理、スマホ最適化（簡易レスポンシブ程度）

---

## 1. 現状（リポジトリの実装状況）

### 1.1 構成
- `backend/`: Express + SQLite（APIサーバ）
- `frontend/`: Vite + React（UI）

### 1.2 既にあるもの（MVP観点）
- 顧客一覧/検索 API（`GET /api/companies`）
- 顧客詳細 API（`GET /api/companies/:id`）: ルーム一覧・要約・直近メッセージ
- ルーム管理（簡易）: ルーム作成・顧客紐づけ・メッセージ取り込み（管理画面/管理API）
- 要約生成（現状は簡易ロジック）: `POST /api/companies/:id/regenerate`
- DBスキーマ: `users`, `companies`, `chat_rooms`, `messages`, `summaries`

### 1.3 未完/改善ポイント（MVP観点）
- 認証がダミー（サーバが自動ログインする前提）
- Chatwork API からの「取得・同期」が未実装（現状は手動取り込み）
- LLM による要約（外部API）に未接続（現状は簡易要約）
- 定期ジョブ（同期→要約更新）の運用形が未確定

---

## 2. チケット運用ループ（ここが回せればOK）

### 2.1 1チケットの完了定義（Definition of Done）
- 目的/受入条件を満たす
- 影響範囲が説明できる（どこを触ったか）
- 下の「共通確認セット」を実行し、NGがない
- 可能なら簡単な手動確認手順もメモに残す

### 2.2 共通確認セット（毎チケットの最後に実行）
```bash
# 1) APIのスモーク
npm run smoke

# 2) フロントのビルド（最低限）
npm run build
```

任意で追加（UI変更がある場合は推奨）:
```bash
npm --prefix frontend run lint
```

### 2.3 チケットのテンプレ
- **ID**: TKT-XXX
- **目的**: 何を満たすか（ユーザー価値）
- **スコープ**: やる / やらない
- **実装メモ**: 仕様の補足・判断
- **変更箇所**: ファイル・API・DB
- **受入条件**: “〜できる” を箇条書き
- **確認手順**: コマンド + 手動確認（UIの導線）

---

## 3. チケット一覧（優先度つき）

以下は「MVPを成立させるP0」→「拡張P1」→「将来P2」の順です。
実装は **上から順に** 回す前提で組んでいます（依存関係をなるべく直列にしています）。

---

## M0. 開発土台（Done）

### TKT-001: フロント/バック分離（Done）
- 目的: 開発しやすいディレクトリ構成に整理する
- 状態: 完了（`backend/` と `frontend/` に分離、ルートから `npm run dev` 可能）
- 確認: `npm run smoke`, `npm run build`

---

## M1. MVP要約ツール（P0）

### TKT-010: 認証をダミーから実実装へ置き換え（ログイン/ログアウト）
- 目的: 「社内メンバーのみ利用」を最低限満たす
- スコープ:
  - やる: ログイン画面、セッション発行、`/api/me` の正当化、ログアウト
  - やらない: SSO/部署別権限、パスワードリセット、MFA
- 実装メモ:
  - DBの `users` を利用し、`bcryptjs` で照合（既に依存あり）
  - 現状の auto-login middleware を削除/無効化
  - 未ログイン時は API を 401 に統一（少なくとも `/api/*`）
- 変更箇所（候補）:
  - `backend/src/server.js`（認証ミドルウェア、ルート）
  - `frontend/src/App.jsx` + `frontend/src/pages/Login.jsx`（追加）など
- 受入条件:
  - 未ログインで `GET /api/me` が 401 を返す
  - ログイン成功で以降のAPIが使える
  - ログアウト後にAPIが 401 になる
- 確認手順:
  - `npm run smoke`（必要なら smoke をログイン前提に更新）
  - `npm run dev` で UI からログイン→一覧→詳細が開ける

### TKT-020: Chatwork API クライアントの土台（疎結合なサービス化）
- 目的: 後続の「同期ジョブ」「ルーム一覧取得」を安全に実装できる形を作る
- スコープ:
  - やる: `chatworkService`（HTTP呼び出し・エラーハンドリング・タイムアウト）
  - やらない: リトライ戦略の高度化、レート制限の最適化（最小でOK）
- 実装メモ:
  - 環境変数（例）: `CHATWORK_API_TOKEN`
  - 例外は「呼び出し側で判断できるエラー（statusCode/message）」で返す
- 受入条件:
  - ダミー呼び出し（例: rooms取得）が成功/失敗で分岐できる
  - トークン未設定時に分かりやすいエラーになる
- 確認手順:
  - 手動: token 未設定→エラー、設定→疎通OK

### TKT-021: Chatwork ルーム一覧の取得 + 管理画面に反映（紐づけを楽に）
- 目的: 「利用可能な Chatwork ルーム一覧を表示」を満たし、手入力を減らす
- スコープ:
  - やる: 管理API `GET /api/admin/chatwork/rooms`（例）、管理画面で選択可能にする
  - やらない: 自動で顧客推定紐づけ（MVP外）
- 受入条件:
  - 管理画面で Chatwork ルーム一覧が取得できる
  - ルーム選択→`chat_rooms.chatwork_room_id` に保存できる
- 確認手順:
  - `npm run dev` → 管理画面で一覧取得→紐づけ→顧客詳細で Chatwork リンクが開ける

### TKT-030: Chatwork メッセージ同期（手動実行API）
- 目的: 「対象ルーム限定で取得・保存」をMVPとして成立させる（まずは手動）
- スコープ:
  - やる: `POST /api/admin/rooms/:id/sync`（例）で Chatwork から差分取得して `messages` に保存
  - やらない: 5分ごとの自動同期（次チケット）
- 実装メモ:
  - 既存の `chat_rooms.last_synced_at` を差分条件に使う
  - 重複は `messages(chat_room_id, chatwork_message_id)` の UNIQUE で吸収（既に index あり）
- 受入条件:
  - 同じ sync を2回叩いても二重登録されない
  - `last_synced_at` が更新される
- 確認手順:
  - 手動: 同期→顧客詳細のタイムラインに増える→再実行で増えない
  - `npm run smoke`

### TKT-040: LLM要約の導入（まずは置き換え可能なインターフェース）
- 目的: 要約生成を「簡易ロジック」から「LLM」へ移行できる状態にする
- スコープ:
  - やる: `summaryService` を切り出し、実装を差し替え可能にする（`heuristic` / `llm`）
  - やらない: タスク抽出（要件定義のFR-10はMVP外）
- 実装メモ:
  - 環境変数（例）: `LLM_PROVIDER`, `LLM_API_KEY`, `LLM_MODEL`
  - 失敗時は「前回要約を残す」か「簡易要約にフォールバック」かを決める（運用優先ならフォールバック）
- 受入条件:
  - `POST /api/companies/:id/regenerate` が同じI/Fのまま要約を生成できる
  - LLM未設定/失敗時の挙動が明確（エラー or フォールバック）
- 確認手順:
  - `npm run smoke`
  - 手動: UIから再生成して表示が更新される

### TKT-050: 自動同期ジョブ（定期実行）+ 新着がある顧客だけ要約更新
- 目的: 「一定間隔で同期→新着がある顧客だけ要約」を満たす
- スコープ:
  - やる: サーバ起動中に setInterval 等で同期を回す（MVP）
  - やらない: ワーカー分離/ジョブキュー導入（将来）
- 実装メモ:
  - 競合防止（同時実行ガード）を必ず入れる
  - 「前回要約以降に新着があるか」は `messages.max(sent_at)` と `summaries.max(generated_at)` で判断（既存ロジック活用）
- 受入条件:
  - 起動しっぱなしでメッセージ同期→要約更新が進む
  - 変化がない顧客は要約が再生成されない
- 確認手順:
  - 手動: 同期対象ルームに新着→一定時間後に要約更新
  - `npm run smoke`

---

## M2. タスク機能（P1 / MVP後）

要件定義書のFR-05〜FR-10に相当。MVP後に段階的に入れる。

### TKT-100: タスクDB設計・API追加（CRUDの骨格）
- 目的: タスクを顧客に紐づけて一覧/更新できる
- スコープ:
  - やる: `tasks` テーブル、一覧、作成、更新（ステータス/期日/担当）
  - やらない: 編集履歴の完全保存（要相談）
- 受入条件:
  - 顧客詳細でタスク一覧が取得できる
  - ステータス更新ができる

### TKT-110: タスクUI（一覧・更新・絞り込み）
- 目的: ダッシュボードでタスクが運用できる
- 受入条件:
  - 未対応のみ/担当者別/期限でフィルタできる（最小セット）

### TKT-120: LLMによるタスク抽出（下書き→人が確定）
- 目的: メッセージからタスク候補を抽出し運用負荷を下げる
- 実装メモ:
  - いきなり確定せず「下書き」ステータスを用意して確認フローにするのが安全

---

## M3. 通知・レポート（P2 / 将来）

### TKT-200: 期限リマインド（通知手段は要相談）
### TKT-210: 日次/週次レポート生成

---

## 4. 付録：環境変数（案）

`backend/.env` に設定する想定（`backend/.env.example` へ追記して管理）。

- `PORT`
- `SESSION_SECRET`
- `DATABASE_PATH`
- `CHATWORK_API_TOKEN`（M1で追加）
- `LLM_PROVIDER`, `LLM_API_KEY`, `LLM_MODEL`（M1で追加）

